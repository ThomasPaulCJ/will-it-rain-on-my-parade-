<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Will It Rain On My Parade? - Live Build</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Poppins:wght@600;700;800&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #3d4a5d;
        }
        .font-display {
            font-family: 'Poppins', sans-serif;
        }
        .font-prediction {
            font-family: 'Orbitron', sans-serif;
        }
        .font-scalable-data {
            font-size: clamp(1.25rem, 4vw, 1.875rem);
            line-height: 1;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #app-container {
            background: linear-gradient(145deg, #29323c, #485563);
            transition: background 1.5s ease-in-out;
        }
        #app-container.stormy {
            background: linear-gradient(145deg, #1a202c, #2d3748);
        }
        #rain-canvas {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
        }
        .ui-element-raised {
            background: rgba(72, 85, 99, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
        }
        .ui-element-raised:active, .ui-element-pressed {
            background: rgba(72, 85, 99, 0.2);
            box-shadow: inset 2px 2px 6px rgba(0,0,0,0.4);
            transform: translateY(1px);
        }
        .weather-animate-enter {
            animation: fadeIn 0.6s cubic-bezier(0.22, 1, 0.36, 1) both;
        }
        .text-3d {
             text-shadow: 0px 2px 8px rgba(0, 0, 0, 0.15);
        }
        .location-name {
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
        }
        #daily-forecast, #hourly-forecast {
            scroll-behavior: smooth;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #daily-forecast::-webkit-scrollbar, #hourly-forecast::-webkit-scrollbar { display: none; }
        .forecast-item {
            transition: all 0.2s ease;
        }
        .forecast-item.selected {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }
        .forecast-item.selected .hourly-temp, .forecast-item.selected .daily-temp {
            color: white;
        }
        #details-panel, #search-results, .modal-content {
            transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #details-panel {
            background: rgba(41, 50, 60, 0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }
         #search-results {
            background: rgba(58, 70, 88, 0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .modal-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            background: rgba(65, 77, 94, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        input::placeholder {
            color: #d1d5db;
            opacity: 0.8;
        }
        #about-menu {
            transform-origin: bottom right;
            transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            clip-path: circle(0% at calc(100% - 20px) calc(100% - 20px));
        }
        #about-menu:not(.opacity-0) {
            clip-path: circle(150% at calc(100% - 20px) calc(100% - 20px));
        }
        #about-menu li {
            opacity: 0;
            transform: translateX(15px);
            transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #about-menu:not(.opacity-0) li {
            opacity: 1;
            transform: translateX(0);
        }
        #about-menu:not(.opacity-0) li:nth-child(1) { transition-delay: 0.1s; }
        #about-menu:not(.opacity-0) li:nth-child(2) { transition-delay: 0.15s; }
        #about-menu:not(.opacity-0) li:nth-child(3) { transition-delay: 0.2s; }
        #about-menu:not(.opacity-0) li:nth-child(4) { transition-delay: 0.25s; }
        #about-menu:not(.opacity-0) li:nth-child(5) { transition-delay: 0.3s; }
        #about-menu:not(.opacity-0) li:nth-child(6) { transition-delay: 0.35s; }
    </style>
</head>
<body class="overflow-hidden">
    <div id="app-container" class="relative min-h-screen w-full flex flex-col items-center justify-center text-gray-300 overflow-hidden p-4 sm:p-6 md:p-8">
        <canvas id="rain-canvas"></canvas>
        <main class="z-10 flex flex-col items-center text-center w-full max-w-lg md:max-w-xl lg:max-w-2xl relative">
            <div class="relative w-full mb-4 flex items-center space-x-2">
                <input type="text" id="search-input" placeholder="Search a place or enter latitude, longitude..." class="w-full pl-5 pr-4 py-3 text-lg rounded-2xl focus:outline-none placeholder-gray-300 border-none ui-element-raised">
                <button id="get-location-btn" class="p-3 rounded-full ui-element-raised flex-shrink-0" title="Use my current location">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                </button>
            </div>
            <div id="search-results" class="w-full max-h-60 overflow-y-auto rounded-2xl mb-4 opacity-0 -translate-y-4 scale-95 pointer-events-none z-30"></div>
            <div id="weather-display" class="w-full min-h-[220px] flex items-center justify-center"></div>
            <div id="helpful-tip" class="w-full min-h-[50px] text-base sm:text-lg opacity-90 mt-4 px-4 py-2 rounded-full flex items-center justify-center ui-element-raised"></div>
            <div class="w-full mt-6">
                <div id="daily-forecast" class="flex items-center space-x-2 overflow-x-auto p-2"></div>
            </div>
            <div class="w-full mt-4">
                <div id="hourly-forecast" class="flex items-center space-x-2 overflow-x-auto p-2 min-h-[128px]"></div>
            </div>
            <div class="flex items-center space-x-4 mt-8">
                <button id="details-toggle-btn" class="px-5 py-2 rounded-full font-medium text-sm ui-element-raised">
                    Show Details
                </button>
                <button id="gemini-btn" class="px-5 py-2 rounded-full font-medium text-sm ui-element-raised flex items-center space-x-2">
                    <span>âœ¨</span>
                    <span>Ask Gemini</span>
                </button>
            </div>
        </main>
        <div id="details-panel" class="absolute bottom-0 left-0 right-0 z-20 p-6 rounded-t-3xl transform translate-y-full">
            <div class="max-w-4xl mx-auto grid grid-cols-2 sm:grid-cols-3 gap-4 text-center">
                <div><p class="text-sm opacity-70">Temperature</p><p id="temp" class="font-bold font-display text-white font-scalable-data">--</p></div>
                <div><p class="text-sm opacity-70">Feels Like</p><p id="feels-like" class="font-bold font-display text-white font-scalable-data">--</p></div>
                <div><p class="text-sm opacity-70">Humidity</p><p id="humidity" class="font-bold font-display text-white font-scalable-data">--</p></div>
                <div><p class="text-sm opacity-70">Wind Speed</p><p id="wind" class="font-bold font-display text-white font-scalable-data">--</p></div>
                <div><p class="text-sm opacity-70">Rain Probability</p><p id="rain-prob" class="font-bold font-display text-white font-scalable-data">--</p></div>
                <div><p class="text-sm opacity-70">Precipitation</p><p id="precip" class="font-bold font-display text-white font-scalable-data">--</p></div>
            </div>
        </div>
        <button id="info-btn" class="absolute bottom-4 right-4 p-2 rounded-full ui-element-raised z-20">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
        </button>
        <div id="about-menu" class="absolute bottom-16 right-4 w-64 p-4 rounded-2xl ui-element-raised opacity-0 scale-95 pointer-events-none z-10 text-left">
            <h3 class="font-bold text-lg mb-3 text-white">Developed By</h3>
            <ul id="developer-list" class="space-y-2">
            </ul>
        </div>
    </div>
    <div id="gemini-modal-overlay" class="fixed inset-0 z-50 bg-black/70 flex items-center justify-center p-4 opacity-0 pointer-events-none modal-overlay">
        <div id="gemini-modal-content" class="w-full max-w-lg p-6 rounded-3xl transform scale-95 opacity-0 modal-content">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold font-display text-white">âœ¨ Gemini's Suggestion</h2>
                <button id="gemini-close-btn" class="p-2 rounded-full hover:bg-white/10">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="gemini-response" class="text-lg text-gray-300 leading-relaxed min-h-[100px]">
            </div>
        </div>
    </div>
    <script>
        let fullWeatherData = null;
        let selectedDayIndex = 0;
        let selectedHourIndex = 0;
        let searchTimeout;
        const canvas = document.getElementById('rain-canvas');
        const ctx = canvas.getContext('2d');
        const weatherDisplay = document.getElementById('weather-display');
        const helpfulTipEl = document.getElementById('helpful-tip');
        const dailyForecastEl = document.getElementById('daily-forecast');
        const hourlyForecastEl = document.getElementById('hourly-forecast');
        const detailsPanel = document.getElementById('details-panel');
        const toggleBtn = document.getElementById('details-toggle-btn');
        const searchInput = document.getElementById('search-input');
        const getLocationBtn = document.getElementById('get-location-btn');
        const searchResultsContainer = document.getElementById('search-results');
        const geminiBtn = document.getElementById('gemini-btn');
        const geminiModalOverlay = document.getElementById('gemini-modal-overlay');
        const geminiModalContent = document.getElementById('gemini-modal-content');
        const geminiCloseBtn = document.getElementById('gemini-close-btn');
        const geminiResponseEl = document.getElementById('gemini-response');
        const infoBtn = document.getElementById('info-btn');
        const aboutMenu = document.getElementById('about-menu');
        const developerList = document.getElementById('developer-list');
        toggleBtn.addEventListener('click', () => {
            const isDetailsVisible = !detailsPanel.classList.contains('translate-y-full');
            detailsPanel.classList.toggle('translate-y-full', isDetailsVisible);
            toggleBtn.textContent = isDetailsVisible ? 'Hide Details' : 'Show Details';
            toggleBtn.classList.toggle('ui-element-pressed', !isDetailsVisible);
        });
        infoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleAboutMenu();
        });
        document.addEventListener('click', (e) => {
            if (!aboutMenu.classList.contains('opacity-0') && !aboutMenu.contains(e.target) && !infoBtn.contains(e.target)) {
                toggleAboutMenu();
            }
            const isDetailsVisible = !detailsPanel.classList.contains('translate-y-full');
            if (isDetailsVisible && !detailsPanel.contains(e.target) && !toggleBtn.contains(e.target)) {
                detailsPanel.classList.add('translate-y-full');
                toggleBtn.textContent = 'Show Details';
                toggleBtn.classList.remove('ui-element-pressed');
            }
        });
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            const query = searchInput.value.trim();
            const latLonRegex = /^-?\d{1,3}(\.\d+)?, ?-?\d{1,3}(\.\d+)?$/;
            if (latLonRegex.test(query)) {
                hideSearchResults();
                const [latStr, lonStr] = query.split(',');
                const lat = parseFloat(latStr);
                const lon = parseFloat(lonStr);
                if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    searchTimeout = setTimeout(() => {
                        fetchWeather(lat, lon, { name: "Coordinates", country: `${lat.toFixed(2)}, ${lon.toFixed(2)}` });
                    }, 500);
                }
                return;
            }
            if (query.length < 3) {
                hideSearchResults();
                return;
            }
            searchTimeout = setTimeout(() => {
                searchLocations(query);
            }, 500);
        });
        getLocationBtn.addEventListener('click', getUserLocation);
        geminiBtn.addEventListener('click', showGeminiModal);
        geminiCloseBtn.addEventListener('click', hideGeminiModal);
        geminiModalOverlay.addEventListener('click', (e) => {
            if (e.target === geminiModalOverlay) hideGeminiModal();
        });
        async function callGeminiApi() {
            if (!fullWeatherData) return;
            geminiResponseEl.innerHTML = '<div class="flex justify-center items-center h-full"><div class="loader"></div></div>';
            const weather = fullWeatherData.daily[selectedDayIndex].hourly[selectedHourIndex];
            const { description } = getWeatherInfo(weather.code, weather.rainProb);
            const locationName = `${fullWeatherData.name}, ${fullWeatherData.country}`;
            const userQuery = `The current weather in ${locationName} is ${weather.temp} and feels like ${weather.feels}. It's currently ${description} with a ${weather.rainProb} chance of rain and wind speeds of ${weather.wind}. Suggest a fun, interesting, or relaxing activity to do right now based on these conditions. Be creative and specific. Keep the response to about 2-3 sentences.`;
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: userQuery }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    geminiResponseEl.innerHTML = text.replace(/\n/g, '<br>');
                } else { throw new Error("No text returned from API."); }
            } catch (error) {
                console.error("Gemini API call failed:", error);
                geminiResponseEl.textContent = "Sorry, I couldn't come up with a suggestion right now. Please try again later.";
            }
        }
        function showGeminiModal() {
            geminiModalOverlay.classList.remove('opacity-0', 'pointer-events-none');
            geminiModalContent.classList.remove('opacity-0', 'scale-95');
            document.body.style.overflow = 'hidden';
            callGeminiApi();
        }
        function hideGeminiModal() {
            geminiModalOverlay.classList.add('opacity-0', 'pointer-events-none');
            geminiModalContent.classList.add('opacity-0', 'scale-95');
            document.body.style.overflow = '';
        }
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    const { latitude, longitude } = position.coords;
                    fetchWeather(latitude, longitude, { name: "Your Location", country: "Current" });
                }, () => {
                    helpfulTipEl.innerHTML = `<span>Unable to get location. Check browser settings.</span>`;
                });
            } else {
                helpfulTipEl.innerHTML = `<span>Geolocation is not supported by this browser.</span>`;
            }
        }
        async function searchLocations(query) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`);
                const data = await response.json();
                displaySearchResults(data || []);
            } catch (error) {
                console.error("Error fetching locations:", error);
                displaySearchResults([]);
            }
        }
        async function fetchWeather(lat, lon, locationInfo) {
            setLoadingState(true);
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,relativehumidity_2m,apparent_temperature,precipitation_probability,precipitation,weathercode,windspeed_10m&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=auto&forecast_days=7`;
                const response = await fetch(url);
                const data = await response.json();
                processWeatherData(data, locationInfo);
            } catch (error) {
                console.error("Error fetching weather:", error);
                weatherDisplay.innerHTML = `<p class="opacity-80">Could not fetch weather data.</p>`;
            } finally {
                setLoadingState(false);
            }
        }
        function toggleAboutMenu() {
            aboutMenu.classList.toggle('opacity-0');
            aboutMenu.classList.toggle('scale-95');
            aboutMenu.classList.toggle('pointer-events-none');
        }
        function displaySearchResults(results) {
            searchResultsContainer.innerHTML = '';
            if (results && results.length > 0) {
                results.forEach(loc => {
                    const resultEl = document.createElement('div');
                    resultEl.className = 'px-4 py-3 text-left cursor-pointer hover:bg-black/10 rounded-xl text-white';
                    resultEl.textContent = loc.display_name;
                    resultEl.onclick = () => selectLocation(loc);
                    searchResultsContainer.appendChild(resultEl);
                });
            } else {
                searchResultsContainer.innerHTML = `<div class="px-4 py-3 text-center opacity-70">No results found.</div>`;
            }
            searchResultsContainer.classList.remove('opacity-0', '-translate-y-4', 'scale-95', 'pointer-events-none');
        }
        function hideSearchResults() {
             searchResultsContainer.classList.add('opacity-0', '-translate-y-4', 'scale-95', 'pointer-events-none');
        }
        function selectLocation(locationData) {
            hideSearchResults();
            searchInput.value = '';
            const newLocationName = locationData.display_name.split(',').slice(0, 2).join(', ');
            const newLocation = { name: newLocationName, country: "" };
            fetchWeather(parseFloat(locationData.lat), parseFloat(locationData.lon), newLocation);
        }
        function processWeatherData(data, locationInfo) {
            if (data.error) {
                weatherDisplay.innerHTML = `<p class="opacity-80">${data.reason || "Could not fetch weather data."}</p>`;
                return;
            }
            const now = new Date();
            const dailyData = data.daily.time.map((date, index) => {
                const dayStart = index * 24;
                const dayEnd = dayStart + 24;
                const hourly = data.hourly.time.slice(dayStart, dayEnd).map((time, hourIndex) => ({
                    time: new Date(time).toLocaleTimeString('en-US', { hour: 'numeric', hour12: true }),
                    temp: `${Math.round(data.hourly.temperature_2m[dayStart + hourIndex])}Â°`,
                    rainProb: `${data.hourly.precipitation_probability[dayStart + hourIndex]}%`,
                    precip: `${data.hourly.precipitation[dayStart + hourIndex]} mm`,
                    feels: `${Math.round(data.hourly.apparent_temperature[dayStart + hourIndex])}Â°`,
                    humidity: `${data.hourly.relativehumidity_2m[dayStart + hourIndex]}%`,
                    wind: `${Math.round(data.hourly.windspeed_10m[dayStart + hourIndex])} km/h`,
                    code: data.hourly.weathercode[dayStart + hourIndex],
                }));
                return {
                    date: new Date(date),
                    day: new Date(date).toLocaleDateString('en-US', { weekday: 'short' }),
                    code: data.daily.weathercode[index],
                    maxTemp: `${Math.round(data.daily.temperature_2m_max[index])}Â°`,
                    minTemp: `${Math.round(data.daily.temperature_2m_min[index])}Â°`,
                    rainProb: `${data.daily.precipitation_probability_max[index]}%`,
                    hourly: hourly
                };
            });
            fullWeatherData = { ...locationInfo, daily: dailyData };
            selectedDayIndex = 0;
            selectedHourIndex = fullWeatherData.daily[0].hourly.findIndex(h => new Date(`1970/01/01 ${h.time}`).getHours() === now.getHours());
            if (selectedHourIndex === -1) selectedHourIndex = 0;
            renderDailyForecast();
            updateUI();
        }
        function updateUI(isDayChange = false) {
            if (!fullWeatherData) return;
            const dayData = fullWeatherData.daily[selectedDayIndex];
            if (selectedHourIndex >= dayData.hourly.length) {
                selectedHourIndex = 0;
            }
            const hourData = dayData.hourly[selectedHourIndex];
            if (isDayChange) {
                 const { prediction, description, tip, isThunderstorm } = getWeatherInfo(dayData.code, dayData.rainProb);
                 const newContent = `
                    <div class="weather-animate-enter">
                        <p class="text-lg sm:text-xl font-medium opacity-90 mb-2 font-display location-name">${fullWeatherData.name}</p>
                        <h1 class="font-prediction font-black tracking-wider text-3d text-white whitespace-nowrap leading-none flex items-center justify-center gap-x-4 text-[clamp(3rem,16vw,6rem)]">
                            <span>${dayData.maxTemp}</span>
                            <span class="font-sans font-thin opacity-75 transform -rotate-15 inline-block text-[80%]">/</span>
                            <span>${dayData.minTemp}</span>
                        </h1>
                        <p class="text-xl md:text-2xl lg:text-3xl mt-4 opacity-80">${description}</p>
                    </div>
                `;
                weatherDisplay.innerHTML = newContent;
                helpfulTipEl.innerHTML = `<span>ðŸ’¡ ${tip}</span>`;
                updateWeatherEffects(prediction, isThunderstorm, description);
            } else {
                const { prediction, description, tip, isThunderstorm } = getWeatherInfo(hourData.code, hourData.rainProb);
                const newContent = `
                    <div class="weather-animate-enter">
                        <p class="text-lg sm:text-xl font-medium opacity-90 mb-2 font-display location-name">${fullWeatherData.name}</p>
                        <h1 class="font-prediction font-black tracking-wider text-3d text-white whitespace-nowrap leading-none text-[clamp(3rem,18vw,7rem)]">${prediction}</h1>
                        <p class="text-xl md:text-2xl lg:text-3xl mt-4 opacity-80">${description}</p>
                    </div>
                `;
                weatherDisplay.innerHTML = newContent;
                helpfulTipEl.innerHTML = `<span>ðŸ’¡ ${tip}</span>`;
                updateWeatherEffects(prediction, isThunderstorm, description);
            }
            document.getElementById('temp').textContent = hourData.temp;
            document.getElementById('feels-like').textContent = hourData.feels;
            document.getElementById('humidity').textContent = hourData.humidity;
            document.getElementById('wind').textContent = hourData.wind;
            document.getElementById('rain-prob').textContent = hourData.rainProb;
            document.getElementById('precip').textContent = hourData.precip;
            renderHourlyForecast();
        }
        function renderDailyForecast() {
            if (!fullWeatherData) return;
            dailyForecastEl.innerHTML = '';
            fullWeatherData.daily.forEach((day, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = `forecast-item flex-shrink-0 flex flex-col items-center justify-center p-3 rounded-xl cursor-pointer w-24 h-32 sm:w-28 sm:h-36 ui-element-raised text-white`;
                if(index === selectedDayIndex) itemEl.classList.add('selected');
                itemEl.innerHTML = `
                    <p class="font-semibold text-sm">${index === 0 ? 'Today' : day.day}</p>
                    <p class="text-4xl my-1">${getWeatherIcon(day.code)}</p>
                    <p class="font-bold text-lg sm:text-xl font-display daily-temp flex items-center justify-center gap-x-1">
                        <span>${day.maxTemp}</span>
                        <span class="font-sans font-thin opacity-75 transform -rotate-15 inline-block">/</span>
                        <span class="opacity-70">${day.minTemp}</span>
                    </p>
                `;
                itemEl.addEventListener('click', () => {
                    selectedDayIndex = index;
                    selectedHourIndex = 0;
                    updateUI(true); 
                    document.querySelectorAll('#daily-forecast .forecast-item').forEach((el, i) => {
                        el.classList.toggle('selected', i === selectedDayIndex);
                    });
                });
                dailyForecastEl.appendChild(itemEl);
            });
        }
        function renderHourlyForecast() {
            if (!fullWeatherData) return;
            hourlyForecastEl.innerHTML = '';
            const dayData = fullWeatherData.daily[selectedDayIndex];
            const now = new Date();
            let startHour = (selectedDayIndex === 0) ? now.getHours() : 0;
            const hourlyToRender = (selectedDayIndex === 0) ? dayData.hourly.slice(startHour) : dayData.hourly;
            let currentSelectionInSlice = selectedHourIndex - startHour;
            hourlyToRender.forEach((hour, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = `forecast-item flex-shrink-0 flex flex-col items-center justify-center p-3 rounded-xl cursor-pointer w-20 h-28 sm:w-22 sm:h-32 ui-element-raised text-white`;
                if (index === currentSelectionInSlice) {
                    itemEl.classList.add('selected');
                }
                itemEl.innerHTML = `
                    <p class="font-semibold text-sm opacity-80">${hour.time}</p>
                    <p class="text-3xl my-1">${getWeatherIcon(hour.code)}</p>
                    <p class="font-bold text-lg sm:text-xl font-display hourly-temp">${hour.temp}</p>
                `;
                itemEl.addEventListener('click', () => {
                    selectedHourIndex = index + startHour;
                    updateUI(false);
                });
                hourlyForecastEl.appendChild(itemEl);
            });
        }
        let raindrops = []; let splashes = []; let lightning = []; let rainIntensity = 0; let isThunderstormActive = false; let flashOpacity = 0; let clouds = [];
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        class Raindrop { constructor() { this.x = Math.random() * canvas.width; this.y = -Math.random() * 200; this.z = Math.random() * 0.5 + 0.5; this.length = this.z * 15 + 10; this.speed = this.z * 10 + 10; this.angle = -15 * (Math.PI / 180); } update() { this.y += this.speed; this.x += Math.tan(this.angle) * this.speed; if (this.y > canvas.height) { this.reset(); } } reset() { this.y = -20; this.x = Math.random() * canvas.width; } draw(context) { const endX = this.x + Math.tan(this.angle) * this.length; const endY = this.y + this.length; context.beginPath(); context.moveTo(this.x, this.y); context.lineTo(endX, endY); context.strokeStyle = `rgba(255, 255, 255, ${0.4 * this.z})`; context.lineWidth = 1.5 * this.z; context.stroke(); } }
        class Splash { constructor(x, y) { this.x = x; this.y = y; this.particles = []; for (let i = 0; i < 15; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 2 + 2; this.particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2, alpha: 1 }); } } update() { this.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.alpha -= 0.04; }); this.particles = this.particles.filter(p => p.alpha > 0); } draw(context) { this.particles.forEach(p => { context.beginPath(); context.arc(p.x, p.y, 1, 0, Math.PI * 2); context.fillStyle = `rgba(255, 255, 255, ${p.alpha})`; context.fill(); }); } }
        class LightningBolt { constructor() { this.x = Math.random() * canvas.width * 0.6 + canvas.width * 0.2; this.y = 0; this.path = [{ x: this.x, y: this.y }]; this.life = 10; let currentY = 0; while (currentY < canvas.height * 0.6) { const last = this.path[this.path.length - 1]; const newX = last.x + (Math.random() - 0.5) * 40; const newY = last.y + Math.random() * 20 + 10; this.path.push({ x: newX, y: newY }); currentY = newY; } } update() { this.life--; } draw(context) { context.strokeStyle = `rgba(255, 255, 255, ${this.life / 10})`; context.lineWidth = 2; context.beginPath(); context.moveTo(this.path[0].x, this.path[0].y); for (let i = 1; i < this.path.length; i++) { context.lineTo(this.path[i].x, this.path[i].y); } context.stroke(); } }
        class Puff {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.points = [];
                const pointCount = Math.floor(Math.random() * 4) + 5;
                for (let i = 0; i < pointCount; i++) {
                    const angle = (i / pointCount) * Math.PI * 2;
                    const radius = this.r + (Math.random() - 0.5) * this.r * 0.7; 
                    this.points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                    });
                }
            }
            update() { }
            draw(context, color, darkColor) {
                context.beginPath();
                context.moveTo(
                    this.x + (this.points[0].x + this.points[this.points.length - 1].x) / 2,
                    this.y + (this.points[0].y + this.points[this.points.length - 1].y) / 2
                );
                for (let i = 0; i < this.points.length; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[(i + 1) % this.points.length];
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    context.quadraticCurveTo(this.x + p1.x, this.y + p1.y, this.x + midX, this.y + midY);
                }
                const gradient = context.createRadialGradient(this.x, this.y, this.r * 0.2, this.x, this.y, this.r);
                gradient.addColorStop(0, `rgba(${color}, 1)`);
                gradient.addColorStop(0.5, `rgba(${color}, 0.7)`);
                gradient.addColorStop(0.9, `rgba(${darkColor}, 0.5)`);
                gradient.addColorStop(1, `rgba(${darkColor}, 0)`);
                context.fillStyle = gradient;
                context.fill();
            }
        }
        class Cloud {
            constructor(color, darkColor) {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.35;
                this.z = Math.random() * 0.7 + 0.6;
                this.speed = this.z * 0.4 + 0.1;
                this.puffs = [];
                this.color = color;
                this.darkColor = darkColor;
                this.flashLife = 0;
                const puffCount = Math.floor(Math.random() * 6) + 10;
                for (let i = 0; i < puffCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 80 * this.z * (i === 0 ? 0 : 1); 
                    const radius = (Math.random() * 60 + 70) * this.z; 
                    this.puffs.push(new Puff(Math.cos(angle) * distance, Math.sin(angle) * distance, radius));
                }
            }
            update() {
                this.x += this.speed;
                if (this.x - 400 > canvas.width) { this.x = -400; }
                this.puffs.forEach(p => p.update());
                if (this.flashLife > 0) this.flashLife--;
            }
            draw(context) {
                context.save();
                context.translate(this.x, this.y);
                context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                context.shadowBlur = 45 * this.z; 
                context.shadowOffsetY = 20 * this.z;
                context.filter = 'blur(15px)';
                this.puffs.forEach(p => { p.draw(context, this.color, this.darkColor); });
                if (this.flashLife > 0) {
                    const flashOpacity = (this.flashLife / 15) * 0.8;
                    const flashGradient = context.createRadialGradient(0, 0, 50, 0, 0, 200 * this.z);
                    flashGradient.addColorStop(0, `rgba(220, 220, 255, ${flashOpacity})`);
                    flashGradient.addColorStop(1, `rgba(220, 220, 255, 0)`);
                    context.fillStyle = flashGradient;
                    context.beginPath();
                    this.puffs.forEach(p => {
                        context.moveTo(p.x, p.y);
                        const points = p.points;
                         context.moveTo(p.x + (points[0].x + points[points.length - 1].x) / 2, p.y + (points[0].y + points[points.length - 1].y) / 2);
                        for (let i = 0; i < points.length; i++) {
                            const p1 = points[i];
                            const p2 = points[(i + 1) % points.length];
                            context.quadraticCurveTo(p.x + p1.x, p.y + p1.y, p.x + (p1.x + p2.x) / 2, p.y + (p1.y + p2.y) / 2);
                        }
                    });
                    context.fill();
                }
                context.restore();
            }
        }
        function animateWeather() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (isThunderstormActive && Math.random() < 0.02 && clouds.length > 0) {
                const cloudToFlash = clouds[Math.floor(Math.random() * clouds.length)];
                if (cloudToFlash.flashLife === 0) {
                    cloudToFlash.flashLife = 15;
                }
            }
            clouds.sort((a,b) => a.z - b.z); clouds.forEach(c => { c.update(); c.draw(ctx); });
            if (isThunderstormActive && Math.random() < 0.015 && lightning.length === 0) { lightning.push(new LightningBolt()); flashOpacity = 1; }
            if (flashOpacity > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity * 0.5})`; ctx.fillRect(0, 0, canvas.width, canvas.height); flashOpacity -= 0.1; }
            lightning.forEach((bolt, i) => { bolt.update(); bolt.draw(ctx); if (bolt.life <= 0) { lightning.splice(i, 1); } });
            if (rainIntensity > 0 && raindrops.length < rainIntensity * 100) { raindrops.push(new Raindrop()); }
            raindrops.sort((a, b) => a.z - b.z);
            raindrops.forEach((drop, i) => { drop.update(); drop.draw(ctx); if (drop.y > canvas.height - Math.random() * 20) { if (Math.random() < 0.35) { splashes.push(new Splash(drop.x, canvas.height - Math.random() * 10)); } raindrops.splice(i, 1); } });
            splashes.forEach((splash, i) => { splash.update(); splash.draw(ctx); if (splash.particles.length === 0) splashes.splice(i, 1); });
            requestAnimationFrame(animateWeather);
        }
        function updateWeatherEffects(prediction, isThunderstorm, description) {
            document.getElementById('app-container').classList.toggle('stormy', isThunderstorm);
            isThunderstormActive = isThunderstorm;
            if (prediction === 'Yes' || isThunderstorm) { rainIntensity = 2; } 
            else if (prediction === 'Probably') { rainIntensity = 1; } 
            else if (prediction === 'Maybe') { rainIntensity = 0.5; }
            else { rainIntensity = 0; }
            if (description === "Cloudy" && (clouds.length === 0 || clouds[0].color !== '255, 255, 255')) { clouds = []; for(let i=0; i<15; i++) clouds.push(new Cloud('255, 255, 255', '190, 195, 200')); }
            else if (isThunderstorm && (clouds.length === 0 || clouds[0].darkColor !== '65, 70, 75')) { clouds = []; for(let i=0; i<25; i++) clouds.push(new Cloud('100, 105, 110', '65, 70, 75')); }
            else if (rainIntensity > 0 && !isThunderstorm && (clouds.length === 0 || clouds[0].darkColor !== '120, 125, 130')) { clouds = []; for(let i=0; i<20; i++) clouds.push(new Cloud('160, 165, 170', '120, 125, 130')); }
            else if (rainIntensity === 0 && !isThunderstorm && description !== "Cloudy") { clouds = []; }
            if (rainIntensity === 0) { raindrops = []; splashes = []; }
        }
        function getWeatherIcon(code) {
            if (code >= 95 && code <= 99) return 'â›ˆï¸';
            if (code >= 80 && code <= 82) return 'ðŸŒ§ï¸';
            if (code >= 61 && code <= 67) return 'ðŸŒ§ï¸';
            if (code >= 51 && code <= 57) return 'ðŸŒ¦ï¸';
            if (code === 45 || code === 48) return 'ðŸŒ«ï¸';
            if (code >= 1 && code <= 3) return 'â˜ï¸';
            if (code === 0) return 'â˜€ï¸';
            return '...';
        }
        function getWeatherInfo(code, rainProb) {
            const prob = parseInt(rainProb);
            const isThunderstorm = code >= 95 && code <= 99;
            if (isThunderstorm) {
                return { prediction: "Storm", description: "Thunderstorm", tip: "Stay indoors and stay safe!", isThunderstorm: true };
            }
            if (code >= 80 && code <= 82) {
                return { prediction: "Yes", description: "Rain Showers", tip: "Expect sudden downpours.", isThunderstorm: false };
            }
            if (code >= 61 && code <= 67) {
                return { prediction: "Yes", description: "Raining", tip: "Don't forget your umbrella.", isThunderstorm: false };
            }
            if (code >= 51 && code <= 57) {
                return { prediction: "Yes", description: "Drizzle", tip: "Light rain, a jacket might be useful.", isThunderstorm: false };
            }
            if (prob > 70) {
                 return { prediction: "Probably", description: "High Chance of Rain", tip: "It's very likely to rain soon.", isThunderstorm: false };
            }
            if (code === 45 || code === 48) {
                return { prediction: "No", description: "Foggy", tip: "Be careful, visibility is low.", isThunderstorm: false };
            }
             if (prob > 40) {
                 return { prediction: "Maybe", description: "Chance of Rain", tip: "Keep an umbrella handy, just in case.", isThunderstorm: false };
            }
            if (code >= 1 && code <= 3) {
                return { prediction: "No", description: "Cloudy", tip: "Good day for a walk.", isThunderstorm: false };
            }
            if (code === 0) {
                return { prediction: "No", description: "Clear Skies", tip: "Great day for sunglasses!", isThunderstorm: false };
            }
            if (prob > 50) return { prediction: "Maybe", description: "Might Rain", tip: "Uncertain weather, be prepared.", isThunderstorm: false };
            return { prediction: "No", description: "Clear Skies", tip: "Great day for sunglasses!", isThunderstorm: false };
        }
        function setLoadingState(isLoading) { if(isLoading) { weatherDisplay.innerHTML = `<div class="loader"></div>`; hourlyForecastEl.innerHTML = ''; helpfulTipEl.innerHTML = ''; dailyForecastEl.innerHTML = ''; } }
        function initializeApp() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            animateWeather();
            const developers = [
                { name: 'Thomas Paul CJ', url: 'https://www.linkedin.com/in/thomaspaulcj/' },
                { name: 'Adith Abhilash', url: 'https://www.linkedin.com/in/adithabhilash/' },
                { name: 'Vidhusankar CH', url: 'https://www.linkedin.com/in/vidhusankar-c-h-a68716248/' },
                { name: 'Tessa Johnson', url: 'https://www.linkedin.com/in/tessajohnson01/' },
                { name: 'Priya Shaji', url: 'https://www.linkedin.com/in/priyashaji/' },
                { name: 'Keerthana P', url: 'https://www.linkedin.com/in/keerthanapadmakumar/' },
            ];
            developerList.innerHTML = developers.map(dev => `
                <li class="flex justify-between items-center text-white">
                    <span>${dev.name}</span>
                    <a href="${dev.url}" target="_blank" rel="noopener noreferrer" class="hover:text-blue-400 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" fill="currentColor"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                    </a>
                </li>
            `).join('');
            getUserLocation();
        }
        initializeApp();
    </script>
</body>
</html>

